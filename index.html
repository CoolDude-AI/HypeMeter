<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>HypeMeter â€” Live (GDELT + Quotes)</title>
  <style>
    :root{ --bg:#0b0c10; --panel:#151827; --text:#eaf0ff; --muted:#aab1c4; --bar:#2a2f3f; --fill:#6da4ff; --up:#24d17e; --down:#ff5470; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial}
    header{position:sticky;top:0;z-index:10;background:rgba(11,12,16,.86);backdrop-filter:blur(12px);border-bottom:1px solid #21263b;padding:12px 14px}
    .rowbar{display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    h1{font-size:18px;margin:0;font-weight:800;letter-spacing:.3px}
    .tag{font-size:12px;color:var(--muted);margin-top:2px}
    .left{display:flex;gap:10px;align-items:center}
    .flame{font-size:22px}
    .search{flex:1;background:var(--panel);border:1px solid #29304c;border-radius:10px;padding:10px 12px;color:#fff;min-width:220px}
    main{padding:14px;max-width:900px;margin:0 auto}
    .board{background:var(--panel);border:1px solid #21263b;border-radius:12px;overflow:hidden;margin-top:12px}
    .head,.item{display:grid;grid-template-columns:42px 82px 1fr 1fr;gap:10px;padding:12px;border-top:1px solid #1a1f34}
    .head{color:var(--muted);border-top:none}
    .rank{text-align:right;color:var(--muted)}
    .sub{font-size:12px;color:var(--muted);margin-top:6px}
    .price{font-size:12px;margin-top:2px}
    .price.up{color:var(--up)} .price.down{color:var(--down)} .price.flat{color:var(--muted)}
    .meter{background:var(--bar);border-radius:10px;height:14px;overflow:hidden}
    .fill{background:var(--fill);height:100%}
    footer{color:var(--muted);text-align:center;font-size:12px;margin:16px 0}
    @media(min-width:640px){ .head,.item{grid-template-columns:60px 110px 1.2fr 2fr} }
    .tfs{display:inline-flex;gap:6px;background:#151827;border:1px solid #21263b;border-radius:10px;padding:6px}
    .tf{border:0;background:transparent;color:#aab1c4;padding:8px 10px;border-radius:8px;font-weight:700}
    .tf.active{background:#1b1f30;color:#fff;box-shadow:inset 0 0 0 1px #2b3150}
  </style>
</head>
<body>
  <header>
    <div class="rowbar">
      <div class="left">
        <div class="flame">ðŸ”¥</div>
        <div>
          <h1>HypeMeter</h1>
          <div class="tag">Live mentions (last hour / 24 hours) + size-aware hype (demo)</div>
        </div>
      </div>
      <input class="search" id="q" type="search" placeholder="Search tickersâ€¦ (NVDA, TSLA, BTC)" />
    </div>
    <div class="tfs" role="tablist" style="margin-left:8px">
  <button class="tf active" data-tf="1h" aria-selected="true">1H</button>
  <button class="tf" data-tf="24h">24H</button>
</div>
  </header>

  <main>
    <section class="board">
      <div class="head">
        <div class="rank">#</div>
        <div>Ticker</div>
        <div>Name</div>
        <div>Hype</div>
      </div>
      <div id="list"></div>
    </section>

    <footer>Demo uses GDELT counts (last 60m) + quotes from Finnhub via Netlify Functions.</footer>
  </main>

<script>
// ===== CONFIG / STATE =====
const SYMBOLS = [
  ['NVDA','NVIDIA Corp','Equity'],['AAPL','Apple Inc.','Equity'],['MSFT','Microsoft Corp','Equity'],
  ['AMZN','Amazon.com Inc','Equity'],['GOOGL','Alphabet Inc.','Equity'],['META','Meta Platforms','Equity'],
  ['TSLA','Tesla Inc','Equity'],['AMD','Advanced Micro Devices','Equity'],['PLTR','Palantir Technologies','Equity'],
  ['NFLX','Netflix Inc','Equity'],['COIN','Coinbase Global','Equity'],['GME','GameStop','Equity'],
  ['AMC','AMC Entertainment','Equity'],['RIVN','Rivian Automotive','Equity'],['SNAP','Snap Inc','Equity'],
  ['UBER','Uber Technologies','Equity'],['SPOT','Spotify','Equity'],['SHOP','Shopify','Equity'],
  ['DIS','Walt Disney','Equity'],['NIO','NIO Inc','Equity']
];
const EPS = 1e-6;
const clamp = (x, a=0, b=100) => Math.max(a, Math.min(b, x));
const tanh = Math.tanh || (z => {
  const e1 = Math.exp(z), e2 = Math.exp(-z);
  return (e1 - e2) / (e1 + e2);
});
const sigmoid = (z) => 1 / (1 + Math.exp(-z));
const TF_MIN = { '1h': 60, '24h': 1440 };
let TF = '1h';
let LAST_ROWS = [];                 // <-- only declared once
const REFRESH_MS = 5 * 60 * 1000;   // 5 minutes

// ===== RENDERING =====
function rowTemplate(a, i){
  const hype = Number.isFinite(a.hype) ? a.hype : 0;
  const pct = Math.max(0, Math.min(100, hype));
  const chg = Number.isFinite(a.chgPct) ? a.chgPct : 0;

  const priceCls = chg > 0.2 ? 'up' : (chg < -0.2 ? 'down' : 'flat');
  const chgStr = chg ? (chg>0?'+':'') + chg.toFixed(2) + '%' : '';

  return `
    <div class="item">
      <div class="rank">${i+1}</div>
      <div><div class="ticker">${a.t}</div><div class="price ${priceCls}">${chgStr}</div></div>
      <div>${a.n}<div class="sub">${a.sec}</div></div>
      <div>
        <div class="meter"><div class="fill" style="width:${pct}%"></div></div>
        <div class="sub">Score: ${pct.toFixed(0)} / 100 â€¢ mentions: ${a.mentions ?? 0}</div>
      </div>
    </div>`;
}

function render(rows){
  if (rows) LAST_ROWS = rows;
  const q = document.getElementById('q').value.toLowerCase();
  const src = rows || LAST_ROWS;
  const filtered = src.filter(a => (a.t + ' ' + a.n).toLowerCase().includes(q));
  const sorted = filtered.sort((a,b)=> b.hype - a.hype);
  document.getElementById('list').innerHTML = sorted.map(rowTemplate).join('');
}

// ===== DATA LOAD =====
async function loadData(){
  try {
    const tickers = SYMBOLS.map(s=>s[0]).join(',');
    const minutes = TF_MIN[TF];

    const [mentionsRes, quotesRes] = await Promise.all([
      fetch(`/.netlify/functions/mentions?tickers=${encodeURIComponent(tickers)}&window=${minutes}`),
      fetch(`/.netlify/functions/quotes?tickers=${encodeURIComponent(tickers)}`)
    ]);

    // If an endpoint fails, keep last good data visible
    const safeJson = async (res) => (res && res.ok) ? (await res.json().catch(()=>null)) : null;
    const mentions = await safeJson(mentionsRes);
    const quotes   = await safeJson(quotesRes);

    // If both failed, keep showing what we had
    if (!mentions && !quotes) { render(); return; }

    const BASEKEY = `baseline_${TF}`;
    const baseline = JSON.parse(localStorage.getItem(BASEKEY)||'{}');
    const now = Date.now();

    const prevByT = Object.fromEntries((LAST_ROWS || []).map(r => [r.t, r]));

    // ---------- 1) Build a raw snapshot first ----------
    const snapshot = SYMBOLS.map(([t,n,sec])=>{
      const m = Number(mentions?.[t]) || 0;
      const q = quotes?.[t] || {};
      const chgPct = Number.isFinite(Number(q.chgPct)) ? Number(q.chgPct) : (Number(prevByT[t]?.chgPct) || 0);
      const volRel = Number.isFinite(Number(q.volRel)) ? Number(q.volRel) : 1;
      return { t, n, sec, m, chgPct, volRel };
    });

    // Cohort median of non-zero mentions for better seeding
    const nonZero = snapshot.map(s=>s.m).filter(v=>v>0).sort((a,b)=>a-b);
    const med = nonZero.length ? (nonZero[Math.floor(nonZero.length/2)]) : 2; // neutral-ish seed
    const seedBase = Math.max(1, med);

    // Per-timeframe smoothing (slower for 24h)
    const ALPHA = TF === '1h' ? 0.10 : 0.03;

    // ---------- 2) Score computation with stable mapping ----------
    const GAIN = 0.8;               // how aggressively log-ratio moves score
    const VOL_MIN = 0.8, VOL_MAX = 1.2; // soften volume effect

    const out = snapshot.map(s => {
      const baseStored = Number(baseline[s.t]?.m);
      // If no baseline yet, seed to cohort median (not 1, not current m)
      const base = Number.isFinite(baseStored) && baseStored > 0 ? baseStored : seedBase;

      // Core signal: log-ratio vs baseline, passed through tanh so it doesn't explode
      const ratio = (s.m + EPS) / (base + EPS);
      const core  = tanh(GAIN * Math.log(ratio)); // ~ -1..+1
      let hype    = 50 + 40 * core;               // 10..90 for typical moves

      // Gentle volume adjustment (narrow clamp prevents pinning)
      const volAdj = clamp(s.volRel, VOL_MIN, VOL_MAX);
      hype *= volAdj;                              // small nudge, e.g., Â±20%

      // Small price momentum bump (kept subtle)
      const priceKick = 8 * (sigmoid(s.chgPct / 3) - 0.5); // â‰ˆ -4..+4 for common % moves
      hype = clamp(hype + priceKick, 0, 100);

      return { t: s.t, n: s.n, sec: s.sec, mentions: s.m, hype, chgPct: s.chgPct };
    });

    // ---------- 3) Update baseline only if mentions succeeded ----------
    if (mentions) {
      const newBaseline = { ...baseline };
      for (const r of out) {
        const prev = Number(newBaseline[r.t]?.m);
        if (Number.isFinite(prev) && prev > 0) {
          // EWMA update; if m=0, gently decay instead of snapping to 0
          const next = r.mentions > 0 ? (1-ALPHA)*prev + ALPHA*r.mentions
                                      : (0.995 * prev); // slow decay when no hits
          newBaseline[r.t] = { m: Math.max(1, next), ts: now };
        } else {
          // First write uses cohort median, not current m
          newBaseline[r.t] = { m: seedBase, ts: now };
        }
      }
      localStorage.setItem(BASEKEY, JSON.stringify(newBaseline));
    }

    render(out);
  } catch (err) {
    console.error('loadData error', err);
    render(); // keep last good data
  }
}

// ===== WIRING =====
document.addEventListener('DOMContentLoaded', ()=>{
  // search: just re-render (no network)
  document.getElementById('q').addEventListener('input', ()=> render());

  // timeframe buttons
  const tfButtons = document.querySelectorAll('.tf');
  tfButtons.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      tfButtons.forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      TF = btn.dataset.tf;   // '1h' or '24h'
      loadData();
    });
  });

  loadData();
  setInterval(loadData, REFRESH_MS);
});
</script>
</body>
</html>
